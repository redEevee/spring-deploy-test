name: Deploy

on:
  push:
    branches: [main]

permissions:
  contents: read
  packages: write

jobs:
  build:
    name: build-app
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Create .env for CD Deploy
        run: echo "${{ secrets.PRODUCTION_ENV }}" > .env

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR (GITHUB_TOKEN)
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      # owner 소문자 변환 + 표준 태그 생성
      - name: Set image tag (lowercase owner)
        id: meta
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="ghcr.io/${OWNER_LC}/spring-backend:latest"
          echo "DOCKER_IMAGE=${IMAGE}" >> $GITHUB_ENV
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT

      - name: Build & Push (multi-arch)
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            -f Dockerfile \
            -t "${DOCKER_IMAGE}" \
            --push .

  deploy:
    needs: build
    name: Deploy
    runs-on: [self-hosted, deploy-spring-test]
    env:
      DOCKER_IMAGE: ${{ needs.build.outputs.image }}
    steps:
      - name: Install Docker & Compose (AL2023/Ubuntu)
        shell: bash
        run: |
          set -e
          source /etc/os-release || true

          if ! command -v docker >/dev/null 2>&1; then
            echo "[+] Installing Docker engine..."
            if [[ "$ID" == "amzn" && "$VERSION_ID" == "2023" ]]; then
              sudo dnf -y update || true
              sudo dnf -y install docker || true
              if ! command -v docker >/dev/null 2>&1; then
                curl -fsSL https://get.docker.com -o get-docker.sh
                sudo sh get-docker.sh
              fi
              sudo systemctl enable --now docker
            elif [[ "$ID" == "ubuntu" ]]; then
              sudo apt-get update -y
              sudo apt-get install -y docker.io docker-compose-plugin
              sudo systemctl enable --now docker
            else
              echo "Unsupported OS: $ID $VERSION_ID"; exit 1
            fi
          fi

          echo "[i] Docker version:"
          sudo docker --version || true

          echo "[i] Ensuring Compose availability..."
          if sudo docker compose version >/dev/null 2>&1; then
            echo "[i] docker compose available"
          else
            echo "[+] Installing standalone docker-compose binary..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            command -v docker-compose >/dev/null 2>&1 || { echo "[-] Compose install failed"; exit 1; }
          fi

          sudo usermod -aG docker "$USER" || true

      - name: Deploy to Production
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "Starting Backend Production Deployment"

          # 0) Compose 커맨드 확정
          if sudo docker compose version >/dev/null 2>&1; then
            COMPOSE_CMD="sudo docker compose"
          elif command -v docker-compose >/dev/null 2>&1; then
            COMPOSE_CMD="sudo docker-compose"
          else
            echo "::error::Docker Compose not installed."; exit 1
          fi
          echo "[i] Using: $COMPOSE_CMD"

          cd /home/ec2-user/spring-deploy-test

          # 1) .env 디렉터리 충돌 회피 → compose.env 파일 사용
          ENV_FILE="compose.env"
          if [ -d ".env" ]; then
            echo "::warning::.env is a directory. Using $ENV_FILE instead."
          fi

          # 2) env 파일 생성 (printf 사용)
          printf '%s\n' \
            "GITHUB_ACTOR=${{ secrets.GHCR_ACTOR }}" \
            "DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}" \
            "DB_USER=${{ secrets.DB_USER }}" \
            "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" \
            "DB_NAME=${{ secrets.DB_NAME }}" \
            "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" \
            > "$ENV_FILE"

          # 비어있는 시크릿 경고(값 미노출)
          for k in GITHUB_ACTOR DB_ROOT_PASSWORD DB_USER DB_PASSWORD DB_NAME REDIS_PASSWORD; do
            v=$(grep -E "^$k=" "$ENV_FILE" | cut -d= -f2-)
            if [ -z "$v" ]; then
              echo "::warning::Secret '$k' is empty or not set"
            fi
          done

          # 3) GHCR 비대화식 로그인
          GHCR_ACTOR_LC="${{ secrets.GHCR_ACTOR }}"; GHCR_ACTOR_LC="${GHCR_ACTOR_LC,,}"
          if [ -z "$GHCR_ACTOR_LC" ]; then
            echo "::error::GHCR_ACTOR(secret)가 비어있습니다."; exit 1
          fi
          echo '${{ secrets.GHCR_TOKEN }}' | sudo docker login ghcr.io -u "$GHCR_ACTOR_LC" --password-stdin

          # 4) 안전하게 down → pull → up (항상 --env-file 전달)
          $COMPOSE_CMD --env-file "$ENV_FILE" down || true
          sudo docker pull "${DOCKER_IMAGE}"
          sudo docker image prune -f || true
          sudo docker logout || true
          $COMPOSE_CMD --env-file "$ENV_FILE" up -d

          echo "[✓] Deploy finished"
